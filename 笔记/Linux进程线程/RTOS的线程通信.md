
>假如RTOS之间的线程切换为任务1打断任务2。则CPU的物理寄存器实际动作为：
>		1、被打断的任务2会将此时物理寄存器R0-R14(除R13外)包括RC寄存器的值全部存入自身的中止线程栈。
>		2、抢占的任务1，将自身的中止线程栈的数据搬运到物理寄存器，实现当初被其他人打断的现场。
>		3、当任务2再次获得CPU的控制权，他也会将自身中止线程栈中的数据搬运回到实际物理寄存器，以此完成场景复现。
>任务之间放弃CPU的情况多种，最为常见为时间片用光以及资源不可得。当资源为公共资源时，任务如何得知此资源可访问，又或者正在被其他任务占用？RTOS又是如何达到线程同步和通信的？

---
## RTOS的线程(任务)通信
		Linux进程之间存在信号量，在RTOS中也有相同的概念。信号量之间同样有二值信号量，计数信号量，互斥信号量，以及递归互斥信号量。在RTOS中，有专门负责创建信号量的API函数。以此类推，RTOS中，想必也有消息队列，FIFO等通信机制。

RTT开发工具(一个RTOS的开发工具)内，可以一看究竟
![[Pasted image 20230221151358.png]]


### 信号量
##### 二值信号量
>只有0和1两种状态，被访问时，为0，空闲为1；

```C
//假定一个二值信号量已被创建，而且有这样得一个使用场景
void task1()
{
	//假如这个任务是一个传感器，他需要至少三秒的时间才能
	//完成数据的采集
}

void task2()
{
	//这个函数负责处理采集到的传感器数据
}

//如果这两个函数多线程，那么，task2在task1完成任务之前占用CPU
//不仅task1的任务无法完成，task2的功能也无法实现
//效率反而比裸机编程时还要低。但如果加入信号量

void task1()
{
	//假如这个任务是一个传感器，他需要至少三秒的时间才能
	//完成数据的采集

	//在采集数据前，他将创建好的二值信号量获取，0

	//完成数据采集后，将二值信号量释放，1
}

void task2()
{
	//这个函数负责处理采集到的传感器数据
	//他也获取二值信号，入如果此时二值信号为0，他会被堵塞
	//直到信号为1，才能进入运行或者就绪态
	//如此，任务的先后顺序就被解决了。
}

```

这样子似乎很好用，并且，即使任务2先拿到二值信号量，他也会因为数据不全，二放弃信号量，最终，任务1拿到信号量后，任务2就不能运行，去打断任务1了。
并且，信号量的存在，并不会因为中断优先级而失去判断效力，因为即使是更高中断优先级的任务，他也会因为信号量资源访问不到，而被迫进入堵塞状态，没有进入就绪态，再高的优先级也没有意义了。
因此它真的很好用。
_Linux中，没有对互斥锁的结构体进行赋值的话，它就是一个普通的二值信号量罢了。_


##### 计数信号量
>计数信号量有了更大的数值范围【0~65535】，通过设置这个信号量的数值，它可以限制访问这个信号的线程的数量，就像是WIFI的限制接入用户的个数一样。这个限制可以是软限制，超过以后依旧可以访问但效率大大下降，也可以是硬限制，超过之后直接被堵塞，甚至程序出错


##### 互斥信号量
>1、互斥信号量使用上实际和二值信号量没有区别
>2、互斥信号量可以改变拿到这个资源访问权的任务的优先级！

	对于RTOS来说，在控制CPU的使用上，优先级几乎是铁的规则，因此，当一个低优先级的资源，拿到了二值信号量，它也有可能被不访问这个信号量的更高优先级的程序打断。一旦被打断，信号量得不到释放，后续许多需要访问这个信号量的任务，就会全部进入睡眠。如果，打断这个低优先级的程序相当多，那么和这个二值信号量有关的程序，全部都会长时间的不到执行，甚至是说，里面有系统级的高优先级任务，这是非常致命的。因此，为了解决这种问题，互斥信号量诞生了。拿到这个信号量的任务，优先级会被调高，以此防止被其他优先级的程序打断，这样就不会出现上述问题了。


