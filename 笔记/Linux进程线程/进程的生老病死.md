>通过[[进程基础]]，理解了进程是什么，也知道，进程是有始有终的，一个进程诞生时由操作系统赋予资源，在进程死亡后它的资源也将被系统回收。进程从诞生到死亡将有机会经历以下过程
>- 就绪态
>- 运行态
>- 睡眠态/挂起态/暂停态
>- 僵尸态
>- 死亡态

---
#### 1、就绪态
		就绪态是 TASK_RUNNING状态的一种，当程序刚被创建出来的时候，进程有可能处在这种状态，它被分配了时间片资源，同时其他资源又是可得的，但还没有占用CPU，处在排队等待的状态。当轮到它使用自身的时间片资源占用CPU的时候，它将进入执行态。

#### 2、执行态
		执行态是TASK_RUNNING状态的一种，当程序刚被创建处来的时候，进程有可能处在这种状态，它正在使用自己分配到的时间片资源，和其他可访问的资源，正在占用CPU。直到自己的时间片资源耗尽，或者被其他的中断进程抢占CPU。如此，它有可能再次进入就绪态，等待再次占用CPU，而如果它所希望的某个资源不可得，它会进入睡眠态/挂起态。如果在执行的过程中，它收到了进程IPC信号，SIGSTOP/SIGTSTP，它将会进入暂停态。

#### 3、睡眠态
		由于某些资源不可得，进程会进入睡眠态.睡眠态有两种，一种是TASK_INTERRUPTIBLE，指可被打断的睡眠态，另一种是TASK_UNINTERRUPTIBLE，不可被打断的睡眠态。前者在睡眠期间可以被相应的信号唤醒，重新进入就绪态等待占用CPU，而后者是一种深度睡眠，只有睡够了预定的时间才会重新进入就绪态，否则无法被唤醒。

#### 4、暂停态
		暂停态是进程在占用CPU时，收到SIGSTOP/SIGTSIP中的其中一个信号时，它会进入暂停态，这种状态称为TASK_STOPPED，该状态下的进程不再参与调度，但和睡眠态不同，进入了暂停态的进程，它不会将自己已经获得的资源给释放，只有收到SIGCONT，他才会从重新参与系统的调度，也就是进入就绪态。

#### 5、僵尸态
		进程是有始有终的，迟早会死掉，可以是执行问任务寿终正寝，也可能时被异常信号所杀死，例如main函数中的return/exit()，或者线程的pthread_exit()是正常的死亡，发生段错误时候产生的信号SIGSEGV，会异常的杀死进程。但不管进程的死因是什么，最后内核都会调用一个函数do_exit()，来使进程进入一种名为僵尸态的状态，EXIT_ZOMBIE。这里的僵尸，实际上是进程死亡，很多资源被释放后，剩下一个PCB还没有被回收。是进程的尸体。相当于死后依旧留下的骨灰。不过比骨灰高级的是，PCB会记录下进程的死因！当他的亲缘进程访问这个“尸体”，可以知道，他是怎么死的。

#### 6、死亡态
		谁会关心这个进程的死亡呢？自然是他的父进程。父进程派生出子进程的原因必然是让子进程去完成某一项任务，如今子进程死亡，任务办的如何？这些死亡信息，都被封存在子进程死后留下的尸体，也就是PCB中。一般约定，当子进程死亡时，会给父进程发送信号，父进程再去给孩子收尸。当一个进程的PCB被回收，这个进程也就真正的走到了生命的尽头，死亡态。

