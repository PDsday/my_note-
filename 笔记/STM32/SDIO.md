	SD存储卡是专门设计用于满足安全性、容量和可拓展性的存储卡，以满足存储新型的音频和视频的性能和环境需求的电子设备。
	SD存储卡将包括：符合SDMI标准的安全性、更快的读写速度和更高的存储容量。

> SD卡依据读写性能区分有两种：
> 1、可读可写、一般是以空白卡出售，用于大容量的数据存储；
> 2、只读、一般作为软件或视频、音频的分发介质；


---
### SD_BUS
	SD总线上的命令还是数据都是串行输入输出的，且均为数据块，带有起始位，停止位和CRC校验位。常见的SD总线为6线结构，分别为时钟线、CMD、DATA[0:3]。
	命令在CMD上串行传输，数据在DATA上串行传输！
	数据传输遵守高位在前，低位在后

#Command
	由主机向SD卡发出cmd命令，SD卡若支持此命令，将会响应(Response)，否则无响应。

![[Pasted image 20240123150133.png]]

command的数据块结构如下：
![[Pasted image 20240123151341.png]]

Response则有R1\R2\R3\R6等结构区分，R2最长：
![[Pasted image 20240123151524.png]]

#Data
	数据可以从主机发送至SD卡，SD卡也可发送数据到主机。


---
##### 数据帧和读写时序

1、主机向SD卡读取数据：
主机先在CMD线上发出command，SD卡将会发出回应，在回应时，数据已经通过DATA总线发送了。直到主机发送停止读取的command到CMD上。

![[Pasted image 20240123150633.png]]

2、书记向SD卡写入数据：
主机向SD卡发送写入的comand，SD卡受到后，将会回复主机，主机即可通过DATA向SD卡发送数据，每写入一个数据，都要等待SD卡忙标志清空。写入最后一个数据时，及时发送写入结束的command。在多线DAT模式下，只有DAT0会有busy回应。
![[Pasted image 20240123150949.png]]

多线传输下，数据被拆分到4线根DATA上：
![[Pasted image 20240123152552.png]]



### 常用的响应格式
![[Pasted image 20240125155533.jpg]]


---
下面来自翻译：

	在主机与卡之间的通信开始时：
	1、主机可能不知道卡支持的电压，而卡可能不知道它是否支持当前提供的电压。
	2、主机发出一个具有指定电压的重置命令（CMD0），同时假设它可能由板卡支持。
	3、为了验证电压，在物理层规范版本2.00中定义了以下新命令（CMD8）。
	SEND_IF_COND（CMD8）用于验证SD存储卡接口的运行状态。该卡通过分析CMD8的参数来检查操作条件的有效性。
	
	4、主机通过分析CMD8的响应来检查其有效性。供电电压由论证中提出的VHS表示。该卡假定VHS中规定的电压作为电流供应电压。在任何给定时间，仅将1位VHS设置为1。主机同时使用CRC和检查模式来检查主机与板卡之间通信的有效性。如果卡可以在供电电压上操作，响应响应电源电压和命令参数中设置的检查模式。
	如果卡不能在提供的电压下工作，则返回无响应并保持空闲状态。为了初始化高容量SD存储卡，必须在第一个ACMD41之前发出CMD8。接收CMD8使卡意识到主机支持物理层2.00版本，并且卡可以启用新的功能
	
	5、SD_SEND_OP_COND（ACMD41）旨在为SD存储卡主机提供一种机制来识别和拒绝与主机所需的VDD范围不匹配的存储卡。这是通过主机发送所需的VDD电压窗口作为此命令的操作数来完成的（见第5.1章）。不能在指定范围内执行数据传输的卡，应放弃进一步的总线操作，进入非活动状态。OCR登记册中的级别应相应定义（见第5.1章）。请注意，ACMD41是特定于应用程序的命令，因此APP_CMD（CMD55）应始终排在ACMD41之前。在idle_状态下，CMD55将使用的RCA应为该卡的默认RCA = 0x0000。


----
-----
---

# 初始化流程

##### 1、配置STM32
	设置STM32的SDIO。不需要开启中断和DMA。设置IO引脚复用，对SDIO进行基础配置。在与SD卡初步对接前，其时钟频率不得高于400KHz。并打开SDIO的时钟使能。STM32的SDIO可以通过使能CPSM，帮助用户省略复杂的响应解析。

![[Pasted image 20240131104621.png]]


##### 2、结构体
	固件库函数使用三种结构体，辅助配置SDIO寄存器，并发送数据或命令。
	1、SDIO_CmdInitTypeDef
	2、SDIO_DataInitTypeDef
	前者配置命令，后者配置数据。


##### 3、CMD0
	发送CMD0到SD卡，领SD卡进入空闲（IDLE）状态，只有在空闲状态，SD卡才能进行初始化配置。 
	CMD0发送后是没有回应的。

![[Pasted image 20240131110730.png]]

>观察可知：
>1、CMD0的参数 arg 为 stuff bits，位填充，不用特地设置参数；
>2、resp为空，发送后不会接收到回复；

因此，发送CMD0时的SDIO_CmdInitTypeDef配置如下：
![[Pasted image 20240131111050.png]]
由于没有回复，因此，*通过检测STM32的SDIO发送完成标志位*，决定是否进行下一步。


##### 4、CMD8
	CMD8为一个新命令，SD1.0和MMC卡均不支持CMD8命令。
	CMD8用于主机告知SD卡，主机可提供的电压范围。同时，主机会在此步中，设置一个CheckPatternt。如果SD卡收到CMD8，发现主机的工作电压范围不适用与自身将不会回复，若回复，则返回一个同主机的CheckPatternt。

![[Pasted image 20240131112217.png]]

>观察可知：
>1、cmd8的参数包含 VHS和check pattern；
>2、VHS的定义如下：
>![[Pasted image 20240131112434.png]]
>依据使用的SD卡，选择一个与SD卡工作匹配的供电范围。一般为0x0001；
>3、check pattern在常见各类SDIO例程中，一般设置为0xAA。
>4、CMD8将收到R7类型的回复，该命令及其回复的格式如下：
>![[Pasted image 20240131112956.png]]
>![[Pasted image 20240131112859.png]]
>两者*仅在transmission上存在区别*，

因此，CMD8的SDIO_InitTypeDef配置为：
![[Pasted image 20240131113141.png]]
等待STM32  SDIO：
- 判断CMDREND标志位，确认收到R7回复，
- 判断CTIMEOUT标志位，确认是否等待回复超时，若超时，SD卡型号可能位1.0或MMC卡；
- 判断CCRCFAIL标志位，确认是否CRC校验错误，若错误，通讯不可靠，初始化失败。

##### 5、ACMD41
	ACMD41用于主机告知SD卡，主机支持访问的容量类型，以及它将提供的电压范围(OCR寄存器)，无论是那种版本的SD卡，均支持ACMD41。
	
![[Pasted image 20240131115119.png]]

>观察可知：
>1、ACMD41需要设置HCS位，此位表明主机支持何种容量得SD卡。
>![[Pasted image 20240131115531.png]]
>依据手册流程图可知，回复了CMD8，则HCS必须置1，否则为0。
>2、Vdd Vlotage电压范围，此范围对应OCR寄存器的低23位。OCR寄存器的描述如下：
>![[Pasted image 20240131115645.png]]
>观察0-23位，STM32内部稳定驱动电压为3.3V，因此设置20位为1即可。这里选择其他位也没有太大影响。
>3、ACMD41发送后，将会收到R3回应。R3的格式如下：
>![[Pasted image 20240131115900.png]]
>回复的主要内容，为上述OCR寄存器的值。SD卡将会将自身支持的电压范围置1，并将busy位置1，表示SD卡使能，CCS用于区分V2.0的卡，若为0，则为存储容量为1M-2GB的标准SD卡，若为1，则为存储容量为2GB以上的大容量SD卡。

综上，SDIO_CmdInitTypeDef配置为：
![[Pasted image 20240131122029.png]]

发送ACMD41，前需要发送CMD55，ACMD41收到busy等于1之前，需要不断的发送ACMD41。
等待STM32  SDIO：
- 判断CMDREND标志位，确认收到R3回复，判断OCR寄存器的busy和CCS标志；
- 判断CTIMEOUT标志位，确认是否等待回复超时，若超时，初始化失败，需要对SD重新上电；
- 判断CCRCFAIL标志位，确认是否CRC校验错误，若错误，*注意，CMD41CRC固定为1111,需要忽略CRC错误*。


##### 6、CMD2
	CMD2用于获取卡的CID信息，每个卡的CID信息都是独特的。发送CMD2将获得一个长响应。

![[Pasted image 20240131140935.png]]
>观察可知：
>1、CMD2和CMD0一样，将参数设置为0即可；
>2、CMD2发送后将获得一个R2响应这是一个长响应，R2响应包含SD卡CID寄存器的信息，R2响应如下：
>![[Pasted image 20240131141156.png]]



##### 7、CMD3
	CMD3命令用于获取卡的RCA与卡状态，RCA是卡初始化完成后，cmd55的参数。

![[Pasted image 20240131141932.png]]

>观察可知：
>1、CMD3同CMD0一样，参数设置0x00即可；
>2、CMD3将返回R6响应，R6携带的32为数据，R6的格式如下：
>![[Pasted image 20240131142651.png]]
>R6携带数据中，高16位为RCA，低16位分卡的状态位【23、22、19、12：0】，状态为对应如下：
> #23/22位：CRC校验位/CMD合法位，确认当前CMD的CRC是否正确，命令是否匹配卡状态。
>![[Pasted image 20240131143454.png]]
> #19位：Card错误位，进入错误状态此位将被置位
>![[Pasted image 20240131143757.png]]
> #其余12位
> ![[Pasted image 20240131144236.png]]

因此，SDIO_CmdInitTypeDef配置如下：
![[Pasted image 20240131142226.png]]
接收到响应，获取卡的RCA后，即可进行下一步，可添加对card状态的判断，更为严谨。


##### 8、CMD9
	CMD9用于获取卡的各种信息，包括卡的存储大小，卡一次读写的最大、最小字长，数据块等等。CMD9的信息如下：

![[Pasted image 20240131145050.png]]

>观察可知：
>1、CMD9命令的高16位需要携带卡的RCA，其他位为0即可；
>2、CMD9将获得R2响应，该响应格式如下：
>![[Pasted image 20240131145359.png]]
>CMD9的R2响应将携带CSD信息，CSD信息如下表：
>![[Pasted image 20240131145607.png]]
>按位解析接收到的长响应即可。
>SD卡的CSD寄存器有两个版本，V1.0和V2.0，在数据位分配上存在一定的差别，项目所用卡为V1.0版本。

SDIO_CmdInitTypeDef的配置为：
![[Pasted image 20240131160112.png]]

获得长相应后，解析CSD数据，计算卡的各类信息。


##### 9、需要需要计算的Card Info
卡的容量是需要计算的，计算方式如下：
![[Pasted image 20240131160315.png]]

##### 10、发送CMD7选中SD卡
	依据流程图，SD卡需要接收CMD7后，才能转入传输，或者其他的状态下：CMD7是卡传输状态的重要命令。

![[Pasted image 20240131161313.png]]

	CMD7的格式如下：

![[Pasted image 20240131161450.png]]

>观察可知：
>1、参数为卡的RCA，并将RCA放置为高16位；
>2、CMD7的回应为R1；
>3、CMD7作为卡标准状态和传输状态，或编程状态和断链状态的中间命令。
>4、如果RCA=0，将取消卡的选择。只有被选择的卡才能通讯。
>5、该命令返回的R1响应已有介绍。

SDIO_CmdInitTypeDef为：
![[Pasted image 20240131162024.png]]


##### 11、设置Block Size(CMD16)（非初始化）
	CMD16用于设置块的大小。对于标准容量SD存储卡，此命令将为以下所有块命令（读、写、锁）设置块长度（以字节为单位）。默认的块长度固定为512字节。只有当CSD中允许进行部分块读取操作时，设置长度才对内存访问命令有效。在高容量SD存储卡的情况下，由CMD16命令设置的块长度不影响内存读写命令。总是使用512字节的固定块长度。此命令对LOCK_UNLOCK命令有效。在这两种情况下，如果块长度设置为大于512字节，则卡设置BLOCK_LEN_ERROR位。
	
![[Pasted image 20240201090822.png]]
>观察可知：
>1、块是SD卡读取大小的基本单位；
>2、发送CMD16降火获得R1回应；

![[Pasted image 20240201093409.png]]
除了设置SD卡的块大小，STM32的SDIO的数据块大小也要一起设置，保持统一。
通过配置SDIO_DataInitTypeDef实现：
![[Pasted image 20240201093450.png]]


##### 12、访问SD卡的SCR寄存器内容（ACMD51）（非初始化）
	ACMD51用于访问SCR寄存器。ACMD51与其他命令不同的一点是，除了会收到一个相应外，还会收到一个64个bit(8个字节)的Data，这也是为什么先用CMD16设置块大小为8个字节的原因。
	SCR中，可以查看SD卡是否支持宽总线，方便后续设置总线宽度时有参照。

SCR寄存器如下：
![[Pasted image 20240201100310.png]]


![[Pasted image 20240201095236.png]]

>1、STM32的SDIO接收到数据后，会将数据暂存再FIFO中；
>![[Pasted image 20240201095644.png]]
>2、接收到的SCR寄存器的内容，是低位在前，高位在后，需要对数据做位置调换；
>![[Pasted image 20240201095628.png]]

SDIO_Cmd_InitTypeDef配置如下：
![[Pasted image 20240201095736.png]]


##### 13、重新设定STM32的DATA线宽（ACM6）
	如果使用的SD卡不是MMC卡，访问SCR寄存器，确认可以设置宽总线就可以启用4位的数据线宽了。或者继续使用默认的1位的数据线宽。4位时的读写速率自然要比1位的高。

![[Pasted image 20240131162704.png]]
重新初始化，或者直接进行寄存器操作均可。
	![[Pasted image 20240131162754.png]]
设置线宽不仅仅需要配置STM32，SD卡也需要统一线宽设置。

	ACMD6命令用于配置SD卡的DATA线宽。
	
![[Pasted image 20240131172505.png]]
>观察可知:
>1、参数的低2位用于设置DATA线宽，仅有0x00---单线模式，和0x10---四线模式；
>2、设置的线宽最终会将配置SD卡的SCR寄存器；
>3、该命令将获得R1类型的响应；

SDIO_CmdInitTypeDef配置为：
![[Pasted image 20240131172753.png]]
ACMD为拓展命令，发送ACMD前，优先发送CMD55。获得RCA后，可以将CMD55的参数设置为RCA（高16位），当总线上有多个SD卡设备时，CMD55设置RCA后就不会进行群发。

---
	
	完成上面的配置后，SD卡的初始化基本完成，进行数据交互时，可以将时钟频率提高，设置DMA通道或者中断进行对SD卡的高速读取。

----




##### 14、读SD卡（CMD16+CMD17）
	读取SD卡前，通过CMD16配置块大小后，在通过CMD17设定读取的起始地址。SD卡收到CMD17并回复R1响应后，将会把数据从Data总线发送到STM32-SDIO的FIFO中。
	
![[Pasted image 20240201111624.png]]

	综上可知：SD卡需按块读写，且每次读写块大小为512个byte,如果读取或写入的块超过512，卡的BLOCK_LEN_ERROR状态将会置位。
	标准容量的SD卡的通过CMD16设置读写块的大小，块大小尽量为4字节的倍数，方便DMA数据传输时，FIFO按字长操作。



###### 读流程：
1、先通过CMD16设置读写的块大小，不超过512个byte。
这个设置STM32要求为2的指数，用于配置STM32的数据控制寄存器，指数可用如下：
![[Pasted image 20240220121458.png]]
按SD卡默认的512字节大小配置即可，STM32的配置如下：
![[Pasted image 20240220121759.png]]
接着发送CMD17进行读取，cmd17的参数为读取地址，同时打开STM32的DMA通过进行接收数据。
![[Pasted image 20240220122021.png]]

STM32的DMA配置如下：
![[Pasted image 20240220140614.png]]
启用硬件流控，确保大体量数据收发的正确性和稳定性。





##### 15、写SD卡（CMD16+CMD13+CMD24）

	同读SD卡，先清空STM32的SDIO数据寄存器的配置。
	
![[Pasted image 20240221090223.png]]

	目前所用的CMD的回复均为R1，R1携带有SD卡的状态信息，可以判断卡的状态。检测是否出现锁卡的情况。这一步非必要，如果对卡操作有自信，可以省略。
	
![[Pasted image 20240221090428.png]]

	发送CMD16设置写操作的块大小，默认的512byte最合适。

![[Pasted image 20240221090837.png]]

	等待回复，确认回复无误后，即可准备发送CMD24启用单块写操作。

![[Pasted image 20240221094751.png]]

	利用DMA完成数据发送即可。

![[Pasted image 20240221144226.png]]

![[Pasted image 20240221144245.png]]

 



