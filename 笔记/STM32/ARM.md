>大可以把ARM公司理解成是一个设计芯片架构的厂商，它的芯片架构产品也逐年迭代。

---
## 1、计算机体系结构
		计算机的体系结构一般是计算机开发人员希望了解一个处理器的必经之路。
		- 体系结构包含了对该计算机微处理器的属性描述
		- 表征着计算机的的逻辑结构和功能特性
		- 体系结构主要包括：
					- 1、微处理器所支持的指令集（指令系统）
					- 2、基于该体系结构的微处理器的编程模型
					- 3、寄存器组

> _即使是同一种体系结构所设计处来的微处理器，他们之间的性能也会有差异，使用的领域也有所不同。ARM处理器在多数微处理器种脱颖而出，是因为它的处理器架构简单、体积小、功耗低，并且实现了较高的代码密度和性能。_

##### - ARM处理器体系结构如今有：
ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等

##### - 内核系列
一个体系结构又分为不同的内核系列。
例如：ARMv7体系架构下，有三个版本，分别是ARMv7-A、ARMv7-R、ARMv7-M。
这三种同一代的不同体系结构所设计处来的内核产品各不相同。
例如：ARMv7-A有Cortex-A8，A9，A15
![[Pasted image 20221211200114.png]]

_**即使是不同体系结构的ARM处理器性能差异很大，指令集的功能更是不同，但是ARM的体系结构在各个版本之间保持了很高的兼容性，因此，基于这些版本的应用软件也是兼容的，因此ARM的学习成本并不会突然拔高，这也是ARM架构成为常青藤的原因。**_

（内核系列带T意味着支持Thumb指令）

![[Pasted image 20221211200441.png]]
![[Pasted image 20221211200456.png]]

>ARM公司将自己的内核系列的结构卖给开发商，收取版权费为生。其余厂商依据这些架构设计出性能各异的芯片。

![[Pasted image 20221211200648.png]]

![[Pasted image 20221211200705.png]]
![[Pasted image 20221211200734.png]]


## 2、Cortex系列
>ARM对自家的芯片的适合的应用场景做了一个划分参考
>ARMv7体系结构下的-A，-R，-M分别对应具体的内核系类Cortex-A，-R，-M。
>

###### - ARM-Cortex-A：应用程序型
>		这一类型在MMU（内存管理单元）和硬件浮点单元的基础上实现了虚拟内存系统架构，适用于高端消费的电子领域，例如手机，只能手环机顶盒等等。
>

###### - ARM-Cortex-R：实时控制型
>		这一类型针对高性能、高实时性应用，例如汽车控制系统（安全气囊，制动系统），移动通信的几代控制器、网络打印机、硬盘控制器等等。

###### - ARM-Cortex-M：微控制器型
>		针对低功耗、高性能产品，面向嵌入式控制及工业控制领域更多

M系列就是STM32的内核系列

---
## 3、Cortex-M3
>Cortex-M3是STM32F10x的采用的ARM架构。也是常见的微处理器架构之一。其架构组成一般为内核（core）、内部外设NVIC、Sys tick、可裁剪的内存保护单元MPU、以及总线矩阵和调试系统构成。在此架构基础上，半导体厂家做片外外设扩展。得到一块基于ARM cortex-m3架构的微控制器。

_**开发人员无需关注过多的参数，重点了解三大模块：寄存器组、存储器映射以及中断与异常**_

##### Cortex-M3的片上寄存器组
		Cortex-M3共有17个片上寄存器，分为R0-R12的通用寄存器、R13-R15的特殊寄存器。在指令集操作内核时，在代码上就像是通过汇编编写51。这些32位寄存器的不断数据交换，是烧录在芯片上的程序运行的保障。
		R13寄存器是堆栈指针寄存器，发生如中断嵌套时，采用先进后出的方式存储PC寄存器的值；
		R14是链接寄存器（LR），函数嗲用程序跳转时存储程序的返回地址；
		R15时PC寄存器，存储当前程序执行的地址。
		第17个寄存器不叫R16，成为xPSR寄存器，它只是这在这个内核中运行的程序状态，并对中断和执行状态做进一步的控制。他又应用状态寄存器（APSR）、中断状态寄存器（IPSR）、执行状态寄存器（EPSR）组成一个32位的寄存器，他们的标志位丰富，使得控制功能多样。

#IPSR
_作为一个较为重要的寄存器，有必要了解_
它的标志位，有时候又称为一位寄存器：
- PRIMASK                 1(除NMI与硬体错误外，中断不响应)
- FAULTMASK           1(除NMI外，中断不响应)
- BASEPRI(9位)         高于或等于该寄存器设置阈值中断号的中断被屏蔽，若为0，无屏蔽效果

=====
##### 存储结构
		作为32位架构的内核，Cortex-M3的存储器也是32位的，因此它的cpu能够寻址的范围是2^32次方，即4GB。地址映射在此范围外的设备，无法被识别。
		这4GB，其中一部分已经预留给了MPU、NVIC等内部外设，其余部分，则留给半导体厂商做扩展。


![[Pasted image 20221212124845.png]]


#代码区
>系统启动后，中断向量表将默认放在该位置。指令总线和数据总线将从这里取指令/数据。用户编写的代码经过IDE翻译成指令后就存在这里。

#片上SRAM
>芯片制造商在这里布设RAM，代码将在这里运行。这里的最低1MB空间可以按位寻址，成为位带区，对应着一个32MB的位带别名区。仅用于数据访问，不能取指令。

#片上外设
>可映射寄存器，不可执行代码，同样存在1MB的位带区对应32MB的位带别名区。芯片制造商可以在这里添加硬件片上外设。STM32的USART，AD，GPIO就映射在这里。

![[Pasted image 20221212142243.png]]


#片外RAM
>1GB的RAM，当片内的RAM不够时，代码可以在这执行。不过这里没有位带区

#片外外设
> 1GB的片外外设区，当用户外接一些LCD，0809，ROM这类外设，可以将他们映射到此空间。不可以在这里执行代码

#系统区
>系统区，ARM内核架构的东西基本都在这里，并且空间并没有用完，方便后续架构更新，半导体厂商可以在指定范围内使用这里的一部分空间。

---


## 4、启动程序的运行

> ARM芯片在启动用户的代码之前，需要由一段专门的代码来完成对系统的初始化。这一段代码称为启动程序。此代码直接面对最原始的底层硬件，因此往往是汇编语言。这一段程序，将引导系统复位，设置中断向量表，初始化堆栈，设置系统时钟频率，以及跳转用户的C程序。

#### 裸机程序的启动
		裸机编程下，用户直接操作芯片的寄存器，就像是STM32寄存器编程和库函数编程，这两个就属于裸机编程的启动。此时，我们所能够操作的内存地址，都是真实的地址。
		1、上电后，芯片进行复位，系统进入了一个叫做管理模式的状态，此时PC寄存器指向0x00000000处，同时，中断向量表创建完成。
		2、每一个记录在表中的中断，都会获得一个存储空间，存放一个跳转指令，指向中断程序所在的地址，当发生中断时，PC寄存器会依据中断号查找中断向量表，通过向量表的指引，找到中断程序的地址并执行。
		3、堆栈区初始化(在内存中开辟一定大小的空间)，该部分和R13寄存器紧密配合，实现芯片的一系列嵌套操作。
		4、系统时钟初始化，设置芯片的时钟频率
		5、中断初始化。这里，芯片将配置中断的类型，优先级等等，将会涉及一下特殊中断，例如IRQ,FIQ
		6、至此，才进入用户的C程序。

#分析stm32的启动文件，来看看ARM的启动过程
###### 1、从注释结束开始的第一句，为设置栈的大小。EQU是一个伪指令，它的作用像是C语言中的#define，起别名。
![[Pasted image 20230218224512.png]]
######	接下来是设置栈的一些属性
![[Pasted image 20230218225249.png]]
										

###### 2、第二句为，设置堆的大小。
![[Pasted image 20230218224910.png]]

###### 同样的设置堆的属性
![[Pasted image 20230218225341.png]]




###### 3、接下来，是设置中断向量表，他将占据该文件长长的一部分

![[Pasted image 20230218225535.png]]
直到
![[Pasted image 20230218225551.png]]
同样的，对向量表的属性进行了一些设置

###### 4、最后，最重要的部分(其实都重要)
![[Pasted image 20230218225923.png]]

			PROC,是汇编中声明子函数的关键字，声明一个名为 Reset_Handler的子函数
	在这个子函数中，引入其他文件中的两个函数 SystemInit , -- main
			这两个函数在哪里呢？
			SystemInit 位于 stm32f10x.c，用以配置系统时钟
			--main比较复杂，它实际上引导的是stm32f10x.c中的SystemCoreClockUpdate 函数，同时调动main函数

BL描述SystemInit，函数则可以在结束后回到此处，往下执行--main，而修饰main的是BX，一旦执行，函数再也回不来这里了，因此，stm32中的main函数，写入return是会报警告的，写了也没有，因此，写一个while（1）循环在main中，如果不写，这个程序会跑到哪里，无从得知。