>Linux内核是宏内核，但又汲取了微内核的经验，采用了模块化的设计

---

		一个硬件设备，通过IO与芯片连接，芯片运行着从ROM中搬过来的操作系统。系统启动时，bootloard程序会把板子上的硬件描述信息，通过设备树告知系统中的内核，内核将驱动们加载，最终在Linux中以文件的形式存在，放在/dev下。
		例如GEC6818的屏幕，开发者编写好驱动程序，并将他写入内核，内核加载到这个模块，就会产生 /dev/fb0的文件。

		用户是如何调用这些硬件的呢？
		1、首先是用户的入口函数 main 函数；
		2、在 main 函数中，我们 open 设备文件；
		3、 向设备文件的文件描述符中写入信息；
		4、close 设备文件描述符。
		内核有在这之中做了什么呢？
		1、open函数调用，内核会寻找对应的模块入口；
		2、读写函数调用，内核会通过IO访问硬件；
		3、close函数调用，内核会寻找模块的出口。

---
### 1、模块
		Linux内核的开发是多人完成的，因此，每个人的代码风格不同，也存在冲突问题。Linux内核采用了模块化驱动的设计，巧妙的解决了问题。
		模块化的设计还大大的减小了内核的体量，内核代码不用再包含驱动代码。
		那么，一个驱动的程序的设计，就应该是：
		1、生成模块
		2、内核编译
		3、挂载内核

> 1、驱动代码的起始和终止不再是 main函数的入口和出口
> 2、驱动代码的运行者是内核，它的编译需要内核参与，而不是GCC了
> 3、驱动代码运行没有执行文件，在Linux中，是.ko文件，运行是使用命令 insmod
> 4、insmod 挂载驱动，rmmod 删除驱动

---
### 2、流程
##### 1、确认内核
>linux驱动编译者是内核，因此，驱动程序是针对内核的，移植到另一个板子上，必须确认双方内核是否相同，不同，则要用新内核编译过，才能使用。因此确认内核很重要。
>使用命令 uname 可以确认 系统类型。

![[Pasted image 20230317094549.png]]
>有些Linux系统 uname就可以直接看到内核的版本，这里不行，改进一下命令，使用：
>uname -a

![[Pasted image 20230317094924.png]]
>内核本身也是一堆代码，也是需要编译的，这个就涉及内核移植。按下不表。
>内核文件一般放在 /usr/src 下

![[Pasted image 20230317095050.png]]

>以 linux-headers-4.15.0-112-generic 为例：
>headers表明这是内核头文件所在
>4是指内核版本，目前内核版本已经到6甚至远远更高了
>15是主修订版本，一个大版本遇到大漏洞会打大补丁
>0-142是次修订版本，一个大版本遇到小bug会打小补丁
>generic是指这是通用版本内核，也就是稳定版本。

##### 2、创建文件
>我们创建一个目录 hello_driver，并在其下创建文件 hello.c

![[Pasted image 20230317095936.png]]

>linux C语言提供了驱动模块的API，他需要一些头文件，但是系统路径是默认找不到的。
>因此，我们编写驱动代码时，在vscode无法得到很好的支持，比如：
>1、找不到头文件；
>2、没有自动补全；
>其原因在于，vscode找不到驱动所需要代码的头文件在哪里。

![[Pasted image 20230317100230.png]]
>因此，我们需要手动给vscode指明内核头文件路径

![[Pasted image 20230317100548.png]]

>回来后右键头文件，转到定义，能跳转就算成功

![[Pasted image 20230317100936.png]]

>驱动代码是一个模块，因此采用模块化的写法。模块代码是没有main函数的，因此，运行的时候，内核会找不到入口和出口。
>module.h文件中的宏定义负责解决这个问题。
>module_init();
>module_exit();

![[Pasted image 20230317101234.png]]
>依据描述，可以知道，这个宏定义传入一个函数名，以module_init(x)为里，假如传入函数名function1，则内核调用该驱动时，就会以此函数作为入口执行，执行是通过内核API __initcall(x)。实现代码进入内核态。

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

//设置一个入口函数，函数名随意
static int hello_init(void)
{
	 printk("hi hello driver\n");
    return 0;
}

//设置一个出口函数，函数名随意,必须无返回值
static void hello_exit(void)
{
	 printk("goodby hello driver\n");
    
}

module_init(hello_init); //注册入口
module_exit(hello_exit);//注册出口
MODULE_LICENSE("GPL"); //模块协议，按下不表
MODULE_AUTHOR("david.pang");//模块作者
```

>驱动程序是在内核中运行的，输出不再是printf而是printk了，我们希望挂载这个驱动，并在内核打印这两句话。

##### 3、编译
>驱动代码的编译比较复杂，需要makefile的帮助。

```makefile
obj-m:=hello.o
KDIR:=/lib/modules/4.15.0-142-generic/build/
all:
	make -C $(KDIR) M=$(PWD) modules
clean:
	rm -f  *.o *.mod.o *.mod.c *.symvers *.bak *.order *.*.cmd *.*.mk clean
```

>makefile几乎是一个固定的写法。
>1、make
>make是linux的一个编译器之一，和GCC，arm-linux-gcc 一样，是编写驱动用的
>2、-C
>这是一个工作目录跳转标识，意味着，需要$(KDIR)下的工具辅助编译
>3、M=$(pwd)
>$(pwd)在makefile中，默认获取当前文件所在路径，也就是为 make编译器，指定编译的对象。
>4、mdoules
>编译成模块

>最为重要的部分在于，KDIR取别名的这一个路径，它是建立驱动文件代码需要的支持库，不同的开发环境，这个路径不同，需要特别注意。

![[Pasted image 20230317110709.png]]
>如此，就算是编译通过了

##### 4、加载模块，拆卸模块，查看内核日志
>通过命令 insmod会将模块加载进内核，同时内核进入模块接口
>通过命令 rmmod会将模块从内核移除，同时内核退出模块出口
>lsmod查看内核中已经加载的模块
>dmesg查看内核日志

>lsmod查看已有的驱动模块

![[Pasted image 20230317111009.png]]
> sudo insmod hello.ko ,将模块加入内核,lsmod查看到信息

![[Pasted image 20230317111256.png]]
>sudo rmmod hello.ko 移除模块,利用dmesg查看内核打印信息

![[Pasted image 20230317111512.png]]

---

		目前只是揭开驱动的冰山一角，真正的设备驱动，复杂的多，但是框架是不会改变的。
		驱动实际上有两种编译方式，一种就是上述的，将代码编译成ko文件，调试的就insmod加入内核，不要的时候就rmmod移除。这是一个驱动代码调试的常用手段。
		还有一种方式，则是将驱动直接编入内核。这种方法会让驱动在内核启动的时候跟随启动。就像是平时的屏幕驱动，网卡驱动。成熟的驱动都是编入内核的。







