>相对于网络层以下的服务，基本是说一个IP到另一IP，或者说一个MAC地址送到另一个MAC地址的，点对点数据交互。但是，一个主机下，不同的应用有不同的进程，每个进程会占用一个端口。从另一台主机的某个进程过来的数据包，到达传输层后，如何判断这个包要从哪一个端口进入应用层呢？因此，运输层主要解决的，就是从一台主机的某一个端口出发的数据，到达另一台主机某一个端口的端对端的服务。

---
上述的关系可以用下图描述
 
![[Pasted image 20230227111502.png]]

从TCP/IP体系下看单个主机，是这样的：
![[Pasted image 20230227111636.png]]


_**只有两个协议：**_

|TCP|UDP|
|:---:|:---:|
|传输控制协议|用户数据报协议|
|面向连接|无连接|
|端到端的抽象逻辑信道传输|不可靠的传输，没有应答重发，多用于广播|
|常见应用层：电子邮件，万维网，文件传送，远程终端接入|常见应用层：IP电话，流媒体，DNS，选路协议|

		从传输层看，两个传输层之间传输的数据单位叫做 运输协议数据单元 TPDU.
		当使用TCP协议时，这个数据单位协议就是TCP报文段
		当使用UDP协议时，这个数据单位协议就是UDP报文或者用户数据报
	
		对于TCP报文，传输层会对它做相当多的处理，开销不小，因此TCP的传输速率再某些情况要弱于UDP，而对于UDP报文，则是收到就会直接交付，不做任何确认。UDP虽然不可靠，但在某些场景下，UDP是相当有效的工作方式。

---

### 端口
		通信的终点是应用层的应用进程，进程在内核之中存在生老病死，它们的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。有时候，我们会让一个进程关闭后又重新打开，这个进程的进程号就会相应改变，而这种改变却完全不通知对方主机。因此，需要一个功能，有助于双方通信时，能够标识通信的进程，这个标识就是端口号。
		端口是一种抽象的接口，它将网络层及其以下的点对点通信，变成了单个主机下的端对端通信。

##### 软件端口和硬件端口
>硬件端口非常好理解，就是GPIO，或者寄存器的某一个位，都能认为是硬件端口。
>软件端口则是抽象的，它包括数据结构，I/O缓冲区等。

_TCP/UDP报文，通过16个位的大小数据，来标定数据交付的目标端口。_

		每个TCP/UDP报文头部，都包含了源端口号和目标端口号，而这连个端口号，和源IP与目标IP，组成了套接字 socket。在TCP通信时，这个一一指定的方式，为TCP建立了连接。


---
## UDP
		UDP只在IP的数据报服务至上增加了很少的一点功能，也就是端口和差错检错。有差错检测不意味着它就可靠了，和ICMP一样，只能辅助一点点。虽然UDP数据报只能提供不可靠的交付，单数UDP在某些方面有其特殊的优点。

- UDP是无连接的
_发送数据之前不需要建立链接_
- UDP也尽最大努力交付
_数据包会竭尽全力走到终点，但到达终点是什么样子，UDP并不关心(类比暴力运输）_
- UDP是面向报文
_报文没有拥塞控制，像视频和音乐等多媒体，缓冲小。_
- UDP支持群交
_因为没有链接，因此UDP可以一对一，多对一，多对多的通信_
- UDP的数据封装小
_首部只有8个字节_

UDP数据报的格式:
![[Pasted image 20230227115309.png]]

_**1、之所以把源IP，目标IP这里成为伪首部，是因为这部分信息并不是UDP封装的，而是借用网络层IP包的首部封装。但UDP计算校验和的时候，会把这一部分一起算进去。
2、UDP的报文大小是有限制的，并且，他没有缓冲区的概念。***_

---
## TCP
		TCP只能是一对一的通信，但他提供可靠交付的服务，并且提供全双工通信，该协议面向字节流，是因为数据会像水一样先流入缓冲区。

![[Pasted image 20230227133320.png]]


- TCP对进程一次把多长的报文发送到TCP的缓存中是不关心的
- TCP会根据目标的窗口值和网络拥塞的程度来决定一个报文段应该包含多少个字节
- 太长的数据会被TCP分块发送。太短的数据也有可能被TCP等待多点再发送

##### socket套接字
>套接字是源IP/目标IP，源端口，目标端口的抽象！
>TCP链接可以认为是   == >{socket1,socket2} ==> {(IP1,port1),(IP2,port2)};
>操作系统中，直接提供了socket的API函数，其内核联网协议 Berkeley实现，也被成为socket实现


		TCP之所以成为可靠的协议，除了它是面向连接的段对端特点外，还包括以下纠错机制：
     1、超时重传
     TCP的每一段报文，都会等待获得响应后，才发送下一段报文，如果没有收到该段报文的响应，则会重发此段报文。
     2、确认丢失和确认迟到
     前面的超时重传是存在一个问题，就是当目标收到了这段信息，但回应没有回到主机，主机还是会重传此段报文，而原来的已经收到的报文，则会被目标丢弃。
     还有一种情况就是超时重传发生后，确认信号姗姗来迟，此时已经完成了确认丢失，超时重传，TCP就不会对这段姗姗来迟的确认信号有任何反应。

	以上情况下，会发生A信号要等待A信号的反馈才会发送B信号，这是早年的停止等待协议，这样的信道利用率就太低了。目前主流的通信过程，是目标主机不断的发送信号，长时间不受到某个信号的反馈才会重发某个信号。

![[Pasted image 20230227134932.png]]


![[Pasted image 20230227134945.png]]


流水线传输的应用就是连续ARQ协议，他将流水线传输，和自动重传结合。
以下是一种流水线式的响应方式。
![[Pasted image 20230227135047.png]]


		以上方式还不是最好，等待方还可以接受多个数据后，一次发送这些数据的所有响应，这种方式成为累计确认。
		连续ARQ也不是总是好用的，当信号不好时，5个分组里可能丢失了3个分组，发送方只能重发三个分组，但三个分组是和5个分组绑定的，因此这5个分组有一起发了，再次重复操作了2个分组。可见当信号不好时，ARQ会带来负面影响。


#### TCP可靠通信的实现
		超时重传时自动的，TCP的可靠实现还另有其人。分别是：四个窗口，字节序，往返时间RTT


---
### TCP的流量控制
		如果发送者发送太快，而接收者来不及接收，就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，这就是流量控制。是课构成TCP可靠的一方面，运用到四个窗口。
		这四个窗口分别是：
		发送者的发送窗口和接受窗口
		接收者的发送窗口和接受窗口

_流量控制的原理依旧是使用ARQ协议实现，但是采用了滑动窗口的思想。主要方式就是接收方回发的ACK里会包含自己的接收窗口的大小，并利用大小来控制发送方的数据。_

		比如，当发送者发送了一段数据，接受者接受后，会回发ACK，ACK中带有接收者的剩余窗口大小。发送者会按照这个大小，控制下一次发送数据的多少。
		但这并不是两全其美的。首先，当接收者发送一个窗口大小为0的数据，发送者就会等待下一次接收者的窗口不为0的数据。如果这下一个数据，刚好丢失再茫茫网络中，发送者迟迟得不到发送指令，接收者干巴巴等不到数据，形成死锁。
		为了避免这种情况，TCP内有一个时间定时器,定时器会在发送者收到一个0窗口信号时就开始计时，如果在时间范围内，收不到开始发送的窗口值，则会重置发送窗口的数据，开始发送，避免死锁。





