### 类

>类是面向对象编程的一个全新的概念。从表面看，它和结构体非常相似，区别在于，一个使用关键字 class，另一个则是struct。在C++中，struct不再需要typedef就能直接使用结构体名创建结构体类型的变量，而类在结构体的基础上，它的内部可以直接声明甚至定义函数。
>在内部中，类和结构体一样，只有在实例化(创建变量)时，才会占用具体的内存空间。在计算占用内存大小的问题上，类有特殊之处，但基本和结构体相似。

#### 类的成员
```cpp
class A
{

};

//如上述我们就已经定义了一个没有任何成员的类。
```

		在类中的成员分为两类，一类为属性(变量)，一类为行为(函数)。
	
类的成员在不同的[[类的权限]]上体现不同的效果。
_class中，如果没有声明，则默认为私有权限，而结构体则是公有权限_
```cpp
class A
{
	public: //权限
	int a;  //属性
 	
	void a()//行为
	{
		cout<<"我是行为"<<endl;
	}

};
```
---
#### 类的构造
>对类有了初步的了解之后，进一步了解类的构成。
>当我们创建一个类的实例化对象时，编译器会像创建结构体变量时一样，先分配内存空间。而在类中，区别于结构体的一点就是，当分配完这些结构体变量，还会调用这个类的构造函数，对这些变量进行初始化。(默认的构造函数是没有任何操作的)；

```cpp
struct A
{
	int *a;
};
//上述结构体在实例化时，直接调用类的成员属性，指针a，会引发段错误，因为此时的指针a并没有初始化，想要访问不出错，必须这样写。

A temp;
temp.a = (int *)malloc(sizeof(int));

//而在c++的类中，可以这么做；
class A
{
	public :
	A()  //构造函数，与类同名
	{
		this->a = new int;
	}

	int *a;
}

//这时候，直接创建A的实例化对象并访问a指针，并不会出错。
//这是因为，当分配了内存空间以后，会点用这个同类名的函数，析构函数，对内部的成员进行一次程序员希望执行的初始化操作。有了这个析构函数，当创建多个对象时，就无需繁琐的进行初始化。
```
_析构函数在类中有默认的定义，我们直接重写的同名函数实际上是对类的默认构造函数进行了重载，这是c++[[多态]]的体现之一。_

#### 类的析构

>类有默认的初始化自然也有默认的销毁函数，这个函数常常用来回收分配的地址，防止没有及时释放内存而造成内存泄漏的问题。
>这个函数成为类的析构函数，当一个实例化变量离开了他的作用域，或者说被释放时，就会自动调用这个析构函数。

```cpp
class A
{
	public :
	A()  //构造函数，与类同名
	{
		this->a = new int;
	}
	~A() //析构函数，类名前加~
	{
		delete this->a;
	}

	int *a;
}
```

>同样的，节省了程序员写free的时间，减少重复的代码，提高整体的可读性，同时也是有效防止内存泄漏的手段。




