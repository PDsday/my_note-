		Git是一个分布式的项目管理仓库，是目前世界上最先进的分布式版本控制系统。
		听起来难以理解。可以理解为，它会建立一个仓库，用来存放文件，同时它成为这个仓库的管理员，让仓库的查阅者，了解到项目的每一次修改历史。
		GitHub可以说是大名鼎鼎，实际上GitHub也是基于Git的一个全球性的大仓库罢了，这个仓库是免费开放的。另外还有一个GitLab,这是一些企业，学校常用的Git，是不对外开放的仓库。

---
## 集中式版本控制系统和分布式版本控制系统
		集中式版本控制系统，项目都是存放在一个单一的中央服务器中，当有程序员干活的时候，会把项目从服务器复制到本地，修改完之后传到中央服务器。程序员自身的电脑，是不会实时更新项目的变化的。也就是，如果其他的程序员，也对项目进行修改，那么其他人都不得而知。

![[Pasted image 20230314164033.png]]

		分布式版本控制系统则不同。它没有唯一的中央服务器，而是每一个用户的主机，都是一个服务器。每一个程序员的本地主机中，都留存着完整的项目，并且只要联网，项目修改就会实时更新，程序员可以看到谁对项目做出了哪些新的修改。只要这些修改在程序员之间相互推送。

![[Pasted image 20230314164339.png]]

		Git的好处在于，项目有多个存储点，相对于集中式版本控制系统，中央服务器一旦损坏，则整个项目都付之一炬，但分布式的版本控制系统，由于项目存在于多个本地服务器中，单一服务损坏并不会影响到项目的完整性。


## 文件快照
		你到这里可能疑惑，大家把文件发过来，存过去的，这么多复制的仓库，大家都存一个项目的内容，磁盘内存总体上看，其实是存了很多相同的内容，这样的利用率也没多先进。
		实际上，Git所创建的仓库，并不是存放项目文件本身，而是项目的快照。
		快照并不关心项目的具体内容变化。
		这么一说非常抽象。

### 文件备份
>文件备份是区别于文件快照的，存储数据的方式，也是我们一直用的方式，它简单粗暴。

![[Pasted image 20230314170501.png]]

>就好像，每次写了一个代码，就复制上一次的代码在上面进行修改，从而达成文件的备份。在这里，仿佛文件的备份修改时非常流畅的一个事情，这些数据集中的存放在我的文件夹中，并按照命名规则按时间排列，数据也如同水流一般有条不紊的输出。

>但实际上，这种数据流的错觉，是文件系统造成的。我们的数据，实际上是存储在磁盘中的，不连续的块，而文件系统，通过地址指针的方式，让我们得以按顺序得读到文件内容，就好像文件得数据是连续得，流畅的。这些地址指针就像一个流畅的链表，让零散的数据变成了数据流。

			那么一个文件备份(修改)的过程，就是这样的。
			1、复制上一次的项目，这个时候，文件系统会在磁盘中查找零散的项目数据。查找的过程，就是依据已经建立好的，流畅的地址指针链表，将数据搬出来，又存到新的地址当中去。新的零散的地址，又在指针的帮助下，形成一个流畅的流。我们将这些地址指针组成的链表，称为——数据描述结构体序列。
			2、做新的修改。我们在copy出来的备份文件里进行修改，表面是在图形化的界面写写画画，而后台，实际上是调用read，write等IO API函数，而这些函数的本质，又是内核在和文件系统做交互。文件系统，把修改的内容，沿着新的数据描述结构体序列，写入全新的磁盘地址，完成一个修改。

### 文件快照
		到这里，可能你已经发现了，文件的快照，就是哪些指向文件存储磁盘位置的指针们，也就是，数据描述结构体序列。Git只要存储这一个新的数据描述结构体序列就好。就如同，一个int类型的指针，指向的内容里，是10还是100，我指针并不关心！对于老文件，是旧的数据描述结构体序列，对于新的文件，是全新的数据描述结构体序列。

_**Git通过存储一个完整的文件快照，达到存储一个新的项目的目的。**_
_**存储的并不是说，本次修改的和上次项目的差异，而是整个新的项目(快照)**_

---
## Git三大区
		Git工程由三个工作区域:工作目录、暂存(缓存)区域、以及本地仓库。
		分别对应项目文件的三种状态 staged、modified、committed。

>1、在工作区域，你可以随便修改项目文件，但它并不会影响到Git仓库里的任何信息
>2、运行 git add，你对项目的修改，会以一个全新的文件快照方式存储在缓存区
>3、运行 git commit，一个全新的项目快照会被永久保存在Git仓库，其他同事可以通过快照在本地复原出你修改后的项目。


---
## Git的分支
		Git常常用在大型多人项目上。那么，每一个人都在同一个时刻提交一份代码到仓库，里面既有相同的部分，也有不同的部分。但Git的界面永远是显示最新的，所有人整合的结果。这是怎么做到的？

#### 主支
		在Git仓库里，代码的变化永远只有一条时间线，这条时间线的最新点，我们称为 ———— master。
		所以，很容易想到，大家的代码，都是直接放到master里，然后master向后推移。这样就造就了，Git的仓库中，只有最新的代码只有一份。
		
		![[Pasted image 20230315093020.png]]

#### 分支
		当有3个程序员共同开发项目的时候，一个人负责复位按键驱动，一个人负责LED驱动，还有一个人负责整合前两个的代码。那么，他们用Git进行项目管理的过程，会是这样的：
		1、首先，程序员1和程序员2会一起将Git仓库 clone 到本地。这个时候，本地就产生了一个长得和Git master主支一样的分支。这个分支的最新点称为HEAD。
		2、然后，程序员一般不会直接在Head分支上写代码，而是在分支上再复制一个分支，这个最新分支的最新点称为dev。
		3、当程序员1写好了它的代码，他会先将代码提交到Head分支，而Head分支有一个特点，就是它的最新点Head，永远和Master的最新点Master对应。此时，Head分支与Master分支合并，全新的代码就进入了仓库。由于新的代码进入，master再往前走。而后，程序员2的代码合并，程序员3的任务也如上操作。
		随着大家不断的提交代码，分支也就越来越长。


![[Pasted image 20230315093112.png]]






---

# Git实操

### 1、安装Git
安装好Git后，鼠标右键可以看见Git的插件。
![[1678844881931 (2).jpg]]
Git GUI是Git的图形化界面
Git Bash 是Git的Terminal

---


### 2、本地用户注册
>这个用户注册，用于当我们希望clone 或者 commit的时候是必需的，这样子才知道，谁从仓库里拉取/提交了代码。这个用户是仅限本地的。
>- git config --global user.name
>- git config --global user.email
>- git config --global credential.helper store  //这一句的作用就像是记住用户名和密码。

_流程：_
###### 1、打开 Git Bash
![[Pasted image 20230315095603.png]]
>再Git Bash上，Linux的命令是通用的


![[Pasted image 20230315095836.png]]

>使用命令创建一个本地用户


![[Pasted image 20230315100221.png]]

>如上输入后，会在C盘中有一个 Git的配置文件出现，记录着你的用户信息


![[Pasted image 20230315100440.png]]

>也可以通过命令去查看你的信息：
>git config user.name
>git config user.email

![[Pasted image 20230315100555.png]]

---
### 3、创建本地仓库
>要想Git接手管理你的数据，可以是文件，笔记，代码。首先，你要创建一个本地仓库。
>创建仓库的方式有2种：
>1、在本地初始化一个仓库
>2、从远程仓库种克隆一个仓库(后面提)
>前者适合刚开始的项目，而后者则是已有的项目

##### 在本地初始化一个仓库
>在电脑任意的位置，建立一个空目录。

![[Pasted image 20230315101047.png]]
![[Pasted image 20230315101401.png]]

> 进入这个空目录，右键打开Git Bash，或者cd命令跳转，确保路径正确

![[Pasted image 20230315101237.png]]


![[Pasted image 20230315101200.png]]

>在这个文件中，执行命令 git init

![[Pasted image 20230315101441.png]]

>之后，会在这个文件夹中，出现一个隐藏文件，.git文件夹，它就是仓库的配置文件

![[Pasted image 20230315101611.png]]

### 4、操作本地仓库
>此时，我们可以在这个本地仓库中建立的文件。
>例如，建立一个 test.txt
>使用命令 touch test.txt
>或者鼠标右键 新建，随你喜欢。


![[Pasted image 20230315101933.png]]

>此时，回到之间的概念，Git仓库的三大区，工作区，缓存区，仓库，此时，我们就在工作区里，我们对文件的读写操作，不会被记录到仓库里。如果此时其他人拉去这个仓库，什么也拉不到。因为，这个test.txt还没有上库。
>我们通过命令 git status，可以看到如下描述：
>

![[Pasted image 20230315102448.png]]


>通过命令 git add，可以将文件提交到缓冲区。如果有多个文件，可以 _‘git add .’_
>同样的，提交到这里的文件还没有真正进入仓库，我们还能对它进行修改。如果Git会抓取修改，告诉我们，缓冲区的文件有所更新，重新add一遍！
>首先，git add 吧

![[Pasted image 20230315103125.png]]

>如果此时修改 进入了缓冲区test.txt的内容，会怎么样呢？

![[Pasted image 20230315103328.png]]
![[Pasted image 20230315103411.png]]

>因此，重新提交一遍，再次 git add test.txt就好了

![[Pasted image 20230315103546.png]]

>如果进入了缓冲区，就意味着，这个文件将要被你提交入库了，此时还是有机会撤销的，可以使用命令
>git reset 将文件撤出缓冲区 _git reset ._ 撤出全部文件。

![[Pasted image 20230315103904.png]]

>我们再创建一个 b.c文件，然后将test.txt上缓冲区。看看 git status 命令的另一个用法
>git status -s

![[Pasted image 20230315104606.png]]

>A代表的是 Apend，添加。

>对于纯冲区的文件，我们可以将它的快照，拉进本地仓库里了！通过命令，git commit，拉取文件入库(本地仓库)。

![[Pasted image 20230315104921.png]]
> 通过 -m 后缀添加‘日志’，就像是仓库的流水账，查阅流水账可以知道谁对仓库进行了修改！
> 我们可以再这个仓库下，通过命令 git log，查看到谁对仓库进行了什么操作。

![[Pasted image 20230315105253.png]]

>我们把b.c编译一下内容，也提交进仓库里，看看日志 git log 的变化

![[Pasted image 20230315105816.png]]

>此时，我觉得那个乱写的test.txt实在是太掉价了，但他已经进入了本地仓库，我该如何在仓库里删除掉这个文件？
>1、首先，可以通过命令，git ls-files，查看本地仓库里的文件有哪些


![[Pasted image 20230315110512.png]]

>2、使用 git rm 删除掉碍眼的文件吧！

![[Pasted image 20230315110605.png]]

>3、修改了仓库的文件，记得写一下log。仅仅查看log，可以通过命令 git reflog，查看简要的log信息

![[Pasted image 20230315111003.png]]

### 5、现在，一个本地仓库有了，我们将把他变成一个远程仓库，让我们随时随地，有网就能工程！
>首先，你得拥有建立远程仓库的能力，那就是，一个github账号(开源)，或者你公司的gitlab账号(闭源)。那么，登录你的Git Hub吧！

![[Pasted image 20230315115844.png]]


>单词学习：repository  仓库
>首先，创建一个仓库，已有仓库则点击New，没有仓库则点击 create repository


![[Pasted image 20230315161918.png]]


>接下来是对仓库的一些设置

![[Pasted image 20230315162221.png]]

>一个简单的仓库，只要仓库名和一点说明，就能直接创建了。
>创建后会是一个全英文的界面

![[Pasted image 20230315162646.png]]

>很显然，我们要做的就是，第二个提示框里的东西了。
>首先，上传本地仓库到远程仓库，要了解几个概念，URL、HTTP和SSH

##### URL
		统一资源定位器 URL。首先，GitHub也好，GitLab也好，这些远程仓库其实都是网页，而每一个网页在Internet中，必然具有一个唯一的名称标识，这就是URL。简单说，就是一个网址。
		URL具有全球唯一性，通过正确的URL就可以在浏览器上打开指定的网址。
		就比如，输入www.baidu.com，就一定能打开百度搜索栏一样。

![[Pasted image 20230315163817.png]]
		
		URL组成分厂三部分，资源类型，存放资源的主机域名，资源文件名，格式语法一般为：
		protocol :// hostname[:port] / path / [;parameters][?query]#fragment

##### HTTP
		URL的第一个组成部分就是协议，而HTTP就是这样的一个应用层协议，ssh也是。http还有一个更高级的https，它更加安全，因为有过加密计数，比如支付宝的网站，就是https。

![[Pasted image 20230315164130.png]]

		一个https协议的网站，在建立通信隧道时会要求输入账户信息，账户信息有专门的安全隧道，唯有账户信息正确，通信通道才会建立。http对传输层的端口默认80，而https对传输层的端口默认443。


>好了，现在你知道了，想要传输数据到远程仓库，就需要这个仓库的URL，在创建仓库的时候，这个URL已经可见了，分别是 https 协议的URL和ssh协议的URL。

![[Pasted image 20230315164627.png]]


![[Pasted image 20230315164634.png]]
>使用这两种URL的方式传输各有不同，首先来看https方式的传输

![[Pasted image 20230315164908.png]]
>这是官方的命令提示，首先是创建一个仓库，给缓冲区添加一个README.md，然后提交到本地仓库，接着，建立一个分支。这里应该不能说是分支，而是主枝才对。因为远程仓库里目前什么也没有，紧接着就是连接到远程仓库，然后，通过git push命令上库。来试试吧！

![[Pasted image 20230315165203.png]]
>现在，我们的本地仓库一共有这几个东西

![[Pasted image 20230315165241.png]]
>这个本地仓库，历经过这么多的摧残。接下来，先建立一个主分支。然后，连接到远程仓库。
>

![[Pasted image 20230315165557.png]]
>利用 git push -u origin main上库吧！

![[Pasted image 20230315165652.png]]

>输入后，会弹出登录界面,如果此时网页登录着，就会直接进入是否上库，你可以拒绝。

![[Pasted image 20230315165841.png]]

>然后，绑定的邮箱会有人上库的通知，网页也会显示一瞬间的上库完成的英文，现在，回到GitHub，看看加入的库什么样子吧。

上传提示：
![[Pasted image 20230315170107.png]]

![[Pasted image 20230315170402.png]]

>你可能会有疑问，就是，本地仓库中的文件，明明还有一个a.sh，为什么它没有上库呢？
>那么，阅读本地log日志看看。

![[Pasted image 20230315170557.png]]
>可以看到，最新的日志说，我们退回了 0b315a2 时刻，此时，我们只先后完成了，添加test.txt，b.c。那么，如何将漏掉的a.sh补上？

>想必过程已经明显，将a.sh加入本地仓库，然后上传远程仓库。来实试试吧。

![[Pasted image 20230315170933.png]]
>除了首次的上库需要认证，后续的上库不需要再进行认证，a.sh很快的就加入了本地仓库，同时，上远程仓库后，快照，日志等，都得到变化。

![[Pasted image 20230315171134.png]]

>https上库的过程就到这里，ssh则自行尝试

---

### 6、从面向CSDN到面向GitHub编程
>曾几何时，我们写代码总是访问CSDN，通过人家热心的分享百度网盘，下载别人的源码。CSDN的技术力随着你的技术增进，你会发现也就那样了。这个时候，面向全球的GitHub，开源，免费，世界上最大的同性交友网站，映入眼帘，应该如何很好的借鉴(抄袭人家的代码)呢？

>首先，以我们刚上库的程序为例，我们将从远程仓库，拉取源码到自己的本地主机中。


![[Pasted image 20230315171915.png]]
>删除以后，我们像之前建立本地仓库一样，git init一个空间出来

![[Pasted image 20230315172019.png]]
>新的仓库，就叫 Git_repository，接着 git init吧
![[Pasted image 20230315172229.png]]

>然后，开始拉取别人的库吧。

>首先需要一位大怨种

![[Pasted image 20230315172607.png]]

![[Pasted image 20230315172721.png]]


>在左上角的搜索框这样输入：

![[Pasted image 20230315173026.png]]

![[Pasted image 20230315173041.png]]

>相关的项目也就出来的。如果英语足够好，找到自己的毕设也不是没有可能。
>这里，以拉取一个好用的后台清理程序为例。
>这个程序叫做 Memreduct

![[Pasted image 20230315173337.png]]

>搜索后的第一位，就是这位大牛的程序拉！

![[Pasted image 20230315173417.png]]
>点击进去，获取到代码所在的URL
![[Pasted image 20230315173444.png]]
复制之后，来到自己的仓库，git clone吧！

![[Pasted image 20230315173724.png]]
>拉去完成，看看自己的本地仓库吧！
![[Pasted image 20230315173751.png]]

![[Pasted image 20230315173801.png]]

![[Pasted image 20230315173810.png]]
>这位大佬的源码已经被我们尽收囊中~


# 很重要

>如果在一个大工程中，我们不小心删除了仓库中重要的文件，并且，删除的是远程仓库，导致其他程序员拉去不到文件，这可怎么办？被开除，被扣工钱？

![[Pasted image 20230315111329.png]]

>git 有专门恢复文件的手段，防止这种事情发生，这就是利用git管理项目的好处了！

###### 如何删库了不用跑路
###### 1、本地仓库删除怎么办！
> 1、谢天谢地，你的U盘里有备份，重新提交上库就好。
> 2、git reset 这个命令除了将文件撤出缓冲区外，还可根据 git reflog中看见的局部索引值，恢复仓库的上一个状态。这个用法就是 git reset --hard  [局部索引值]

![[Pasted image 20230315112125.png]]

>3、此时，还注意到 git reflog还有一个序列索引 HEAD@{x}，这个花括号中的序列号称为步数，利用命令可以将Git仓库复原到第几步！
>git reset --hard HEAD^
>git reset --hard HEAD~n
>这个^标识后退的到第几步，比如 git reset --hard HEAD^^ 就会后退到2次提交操作前
>如果有太多步要后退，写不下这么多个^，可以使用~n。比如 git reset --hard HEAD~20,将会退到20次提交前！
>那么，我们利用命令，回到第一步，只有个test.txt文件在库中的状态吧！

![[Pasted image 20230315113149.png]]

>4、以上都是已经上传到本地仓库，如何恢复的操作，那么如果在工作区的时候删除了文件，怎么办呢？翻windows的垃圾桶吗？

![[Pasted image 20230315113718.png]]


>比如：
>1、我在工作区，新建立一个 a.sh的shell脚本文件
>2、然后我嘎嘎暴力，rm -rf a.sh，垃圾桶都找不到的那种！
>3、那没有办法，它真的没了

![[Pasted image 20230315114308.png]]
>但如果，我将 a.sh加入了缓冲区，才不小心 rm 掉的，有机会恢复吗？

![[Pasted image 20230315114422.png]]

>是的，它可以！




---
>更多的GitHub的命令，敬请期待













